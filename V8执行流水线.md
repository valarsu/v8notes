# 先上总结

- 计算机只能识别二进制指令，所以要让计算及执行一段高级语言，通常两种手段：
  - 编译执行：
    - 高级代码转为二进制代码，计算机直接执行
    - 启动慢，执行速度快
  - 解释执行
    - 计算机中安装解释器，解释器解释执行代码
    - 启动快，执行速度慢
- V8充分利用上述两种的优点，规避缺点，启动过程中采用解释执行策略，但是如果某段代码执行频率高，那么就用欧化编译器将其编译成机器代码
- V8执行流水线
  1. 初始化基础环境
  2. 解析源码生成AST和作用域
  3. 根据AST和作用域生成字节码
  4. 解释执行字节码
  5. 监听热点代码
  6. 优化热点代码为二进制的机器代码
  7. 反优化生成的二进制机器代码
      - JS是动态语言，在运行过程中，某些被优化的结构可能会被动态修改了，导致之前被优化的带啊吗失效，如果某块代码之后的代码失效了，那么编译器需要执行反优化操作


# V8简介

**本质上，V8就是JS虚拟机的一种，也就是相当于是个翻译程序，把机器不识别的JS翻译成二进制代码**

主要核心流程分为编译和执行两步，首先将JS代码转换为低级中间代码或者机器代码，然后再执行转换后的代码并输出结果。

V8出现之前，所有的JS虚拟机都采用解释执行的方式，这个时代的JS执行速度很慢。

V8引入了即时编译（JIT）的双轮驱动设计。这是一种权衡策略，混合编译执行和解释执行这两种手段，从而提升了JS的执行速度。

此外，V8也还有惰性编译、内敛缓存、隐藏类等机制，进一步优化了JS代码的编译执行效率。

### 高级代码为什么要先编译再执行

首先CPU只能识别二进制指令，为了完成复杂的任务，CPU会指令集来实现各种功能，而指令集就是机器语言。

但是因为二维码对人来说太难了，所以又出现了汇编指令集，就是将机器语言转换为人可以识别的记忆的符号。

```sheel

1000100111011000  机器指令
mov ax,bx         汇编指令
```

但是CPU也不能直接识别汇编语言，所以还需要一个汇编编译器。

> 汇编代码 -> 汇编编译器 -> 机器代码

而汇编语言也是很复杂的，首先写汇编的时候，需要了解处理器架构相关的硬件知识，比如寄存器、内存、操作CPU等，而且不同平台的CPU有不同的指令集，如果要兼容多种不同架构的CPU平台，工作量巨大。

所以呢，就出现了可以屏蔽计算机架构细节的，并且能适应多种不同CPU架构，专心处理业务逻辑，比如C、C++、Java、JS等高级语言。

#### 高级语言的执行过程

##### 解释执行

> 代码 -> 解析器解析 -> 中间代码 -> 解释器执行 -> 输出结果

解释执行启动速度快，执行速度慢


##### 编译执行

> 代码 -> 解析器解析 -> 中间代码 -> 编译器编译 -> 机器代码 -> 执行 -> 输出结果

编译执行启动速度慢，执行速度快

#### JS的几种虚拟机

- Safari JavaScriptCore
- Firefox TraceMonkey
- Chrome V8
- Node.js V8

# V8编译流水线

V8没有采用单一的技术，混合编译执行和解释执行两种手段，也就是即时编译JIT（Just In Time）。

#### V8启动时初始化执行环境

1. 堆和栈空间
2. 全局执行上下文
3. 全局作用域
4. 事件循环系统
5. 内置函数
6. 其他


#### 解释执行
1. 输入代码
2. 结构化，解析器解析生成AST，和相关作用域
3. 生成字节码（介于AST和机器代码之间）
4. 解释器按顺序执行字节码，并输出执行结果

#### 热点代码优化

1. 监控系统发现热点代码
2. 热点代码经过优化编译器编译成二进制代码
3. 优化二进制代码
4. 如果以后再执行这段代码，V8会优先选择优化后的二进制代码执行
5. 如果这段代码被动态修改了，那么优化后的代码就成了无效的代码，优化编译器就需要进行反优化操作，回退到解释器执行

# 实践

##### 输入代码

```js
let test = 'LBGFE'
```
##### 解析器结构化成AST

可以用V8提供的调试工具D8来查看，将上述代码保存到test.js中，执行命令：

###### AST

```shell
d8 --print-ast test.js
```

然后会打印出如下内容：

```shell

--- AST ---
FUNC at 0
. KIND 0
. LITERAL ID 0
. SUSPEND COUNT 0
. NAME ""
. INFERRED NAME ""
. DECLS
. . VARIABLE (0x7ff0e3022298) (mode = VAR, assigned = true) "test"
. BLOCK NOCOMPLETIONS at -1
. . EXPRESSION STATEMENT at 11
. . . INIT at 11
. . . . VAR PROXY unallocated (0x7ff0e3022298) (mode = VAR, assigned = true) "test"
. . . . LITERAL "LBGFE"
```

##### 作用域

```shell
d8 --print-scopes test.js
```
输出：

``` shell
Global scope:
global { // (0x7fd974022048) (0, 24)
  // will be compiled
  // 1 stack slots
  // temporary vars:
  TEMPORARY .result;  // (0x7fd9740223c8) local[0]
  // local vars:
  VAR test;  // (0x7fd974022298)
}
```

上面生成了一个全局作用域，可以看到test变量被添加到了这个全局作用域中。

##### 生成字节码

```shell
d8 --print-bytecode test.js
```
输出：

``` shell
[generated bytecode for function:  (0x2b510824fd55 <SharedFunctionInfo>)]
Parameter count 1
Register count 4
Frame size 32
         0x2b510824fdd2 @    0 : a7                StackCheck
         0x2b510824fdd3 @    1 : 12 00             LdaConstant [0]
         0x2b510824fdd5 @    3 : 26 fa             Star r1
         0x2b510824fdd7 @    5 : 0b                LdaZero
         0x2b510824fdd8 @    6 : 26 f9             Star r2
         0x2b510824fdda @    8 : 27 fe f8          Mov <closure>, r3
         0x2b510824fddd @   11 : 61 32 01 fa 03    CallRuntime [DeclareGlobals], r1-r3
         0x2b510824fde2 @   16 : 12 01             LdaConstant [1]
         0x2b510824fde4 @   18 : 15 02 02          StaGlobal [2], [2]
         0x2b510824fde7 @   21 : 0d                LdaUndefined
         0x2b510824fde8 @   22 : ab                Return
Constant pool (size = 3)
0x2b510824fd9d: [FixedArray] in OldSpace
 - map: 0x2b51080404b1 <Map>
 - length: 3
           0: 0x2b510824fd7d <FixedArray[4]>
           1: 0x2b510824fd1d <String[#5]: LBGFE>
           2: 0x2b51081c8549 <String[#4]: test>
Handler Table (size = 0)
Source Position Table (size = 0)
```

##### 标记热点代码优化执行

###### 查看优化代码

```shell
d8 --trace-opt test.js
```

###### 查看反优化代码

```shell
d8 --trace-deopt test.js
```